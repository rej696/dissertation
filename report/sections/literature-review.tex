\documentclass[../report.tex]{subfiles}
\graphicspath{{\subfix{../images}}}
\begin{document}

\section{Software Engineering in the New Space Industry}
% References:
% - Bousedra_2024: policy paper, may be less useful?
% - Denis_2020: paper discussing trends in the space industry, more relevent?
% - Cubesat_Handbook: book with information about designing cubesats, useful for satellite architecture?
% - Cratere_2024: OBC for Cubesats State of the Art

In the past, developing and launching satellites was the domain of large
corporations and governments due to the costs involved. Recently, In order to
take advantage of cheaper access to space (\autoref{sec:motivation}), a new
type of organisation has begun to build and operate space missions.

\citet{Sweeting_2018} defines New Space as
\begin{quote}
    The emergence of a different ethos for space where the established
    aerospace methods and business have been challenged by more entrepreneurial
    private sector by adopting more agile approaches and exploiting the latest
    commercial-off-the-shelf technologies
\end{quote}

\citet{Denis_2020} describes the current market trends of New Space as
"Darwinism in Space". The creation of new markets in the space environments as
a result of the digital transformation has led to a space industry "gold rush",
with large venture capital investment and a "winner takes all" incentive
driving high levels of competition \citep{Denis_2020}. The impact of this is
that New Space companies must design and manufacture more satellites at a
faster rate and for lower cost if they wish to be competitive.

As a result of the business environment, many New Space start ups have
introduced silicon valley concepts into their businesses, such as "DevOps
culture" and launching Minimum Viable Product (MVP) CubeSats. Furthermore, as
these companies transition from start-ups to mature businesses with an aim to be
profitable, LEAN practices become prevalent, resulting in attempts to reduce
any "wasteful" or expensive practices \citep{Denis_2020}. These market
conditions have led New Space businesses to become more accepting of risk than
their Big Space counterparts \citep{Cratere_2024}

% FIXME should this be edited?
Therefore, Flight Software needs to be developed in shorter time frames and with
lower costs. Satellites in low earth orbit have a shorter lifetime due to
atmospheric drag. CubeSats have a generally high failure rate due to a long
list of possible failure modes which can cripple a platform, with no chance of
repair. Some examples might be a solar panel not deploying, a launch vibration
damaging a critical sensor, or an issue with the thermal management resulting
in the payload having degraded operations. Often, the correctness of the
software systems only becomes an issue when all these barriers have been
passed, and so is a risk that is not considered worth spending time and money
until later in a programme. Thus, new space companies have a vastly different
approach to software systems compared with big space companies, and many of the
approaches used by big space companies to ensure software correctness, such as
extensive system and integration testing and formal methods, are simply to time
consuming and expensive to be applicable in the new space environment.

\section{Satellite Architecture}

Software systems are an essential component of modern satellite designs.
Satellites usually include a number of distributed embedded systems, each
tasked with monitoring and controlling different critical subsystems such as
power, attitude control, communication etc. Typically, a satellite will have a
central on board computer (OBC), or command and data handling subsystem (CDH).

There may be a dedicated guidance navigation and control (GNC) or attitude
determination and control (ADCS) subsystem which runs complex algorithms using
data retrieved from sensors like star trackers, rate sensors, magnetometers and
sun sensors to drive actuators like reaction wheels and magnetorquers in order
to point the satellite. Pointing is critical for many tasks. Payload operation
tasks such as imaging require a high degree of accuracy and responsiveness.
Propulsion manoeuvres, managing thermal loads, power generation (i.e. pointing
the solar panels at the sun to improve the efficiency) all require an effective
ADCS subsystem.

The OBC will be connected to many lower power telemetry (TM) nodes, which are
tasked with monitoring temperatures, voltages and currents, and toggling switches
to enable/disable different subsystems. The OBC will log the telemetry reported
by the TM nodes, and if telemetry exceeds limits, handle fault detection,
isolation and recovery (FDIR).

The OBC or CDH subsystem is responsible for handling communication with a
ground station via a radio, and so provides the interface between a satellite
and the operator. This interface is commonly referred to as Telemetry and
Telecommand (TMTC). The operator uses the TMTC interface on the OBC to download data
from orbit, schedule payload operations, and respond to issues.

Payload computers (PLC) are common on satellites with complex payloads and are
responsible for managing and operating whatever instruments are on board for
delivery of the mission, such as radios, imagers, scientific experiments etc.
On smaller satellites, like CubeSats where payloads are less complex, the
responsibilities of the PLC can be handled by the OBC.


\section{Flight Software Development Challenges}

CubeSats projects tend to make more use of COTS hardware. However, software that
meets the system requirements often cannot be purchased off the shelf, and so
development costs shift from hardware to software
\citep{Cubesat_Handbook_OBSW}. However, there are several flight software
frameworks, such as NASA's Core Flight System (cFS) \citep{Nasa_cFS}, or Bright
Ascensions Generation One (Gen1) Flight Software Development Kit (FSDK)
\citep{Bal_FSDK}. The main aim of these frameworks is to reduce the cost and
development time for Flight Software through code reuse and hardware
abstraction.

For example, a cFS application uses software abstractions of the operating
system and hardware, called the Operating System Abstraction Layer (OSAL) and
Platform Support Package (PSP). This allows correctly written application
code to easily be ported between different hardware architectures such as Arm
Cortex-M or SPARC-V8, and different operating systems like FreeRTOS, RTEMS or
Linux \citep{Nasa_cFS}.

The Gen1 FSDK provides libraries of pre-defined configurable software
"Components", which satisfy common Flight Software requirements, such as
logging telemetry. These pre-defined components can be composed together with
bespoke components into a "Deployment" which can be compiled for several
different COTS hardware options, such as the AAC-ClydeSpace Kryten, or the
GomSpace Nanomind \citep{Bal_Options}.

\citet{Farges_2022} evaluates the use of Software Frameworks in the space
industry. They find a number of quality related benefits, such as increasing
reliance on standardised communication interfaces like CCSDS Space Packet
Protocol; as well as cost related benefits attributable to code reuse between
satellite missions. However, they also identify risks with relying on software
frameworks, such as potential issues with licenses, and the limited
adaptability of software that is highly coupled to a framework, as implementing
functions that aren't currently supported in the framework can be difficult.

Developing flight software for satellite systems is a complex process due to
the large number of different interfaces and interdependencies in the
architecture. Furthermore, due to the space environment, computers used in
satellite systems can have stringent environmental requirements, such as high
radiation tolerance to reduce the likelihood of single event upsets (SEU), low
power consumption and consideration of thermal management. The embedded
microcontrollers that meet these requirements can be more expensive than those
commonly used for other applications, like in automotive systems or IOT devices.

When writing software for embedded systems there is often a critical dependency
on hardware. Writing drivers for devices using only a datasheet can result in
long periods of rework when hardware is available to test against due to
incorrect information or a misinterpretation. The number of interdependent
systems, the costs of these components, and smaller budgets of new space
companies, results in dedicated engineering hardware required for effective
development of embedded flight software being unavailable. Often engineers are
only being able to test with flight hardware, and then have to fit their
testing into a packed schedule to meet tight deadlines.

Software development standards, such as MISRA and NASA's the power of ten exist
to provide guidelines for successfully creating correct software, and hopefully
reduce the burden of testing \citep{NASA_10}. However, while applying these
techniques can reduce the occurrence of introducing bugs during development,
they are not a substitute for system verification.

\section{Fuzz Testing}

Many software programs use a methodology called fuzz testing to automatically
verify software. Fuzz testing is typically used to identify and resolve
security vulnerabilities for programs running on general purpose computers
\citep{Google_2023}. In its most basic form, fuzz testing, or fuzzing, consists
of generating some input test data and monitoring the response of the
software/system under test (SUT) to this input. If the fuzzer detects the
program has crashed, it saves the generated test data for analysis by an
engineer, and mutates the input data in some way to produce a different result.
This brute force approach is known as black-box fuzzing, and given enough time
to execute, will uncover many exploitable bugs with the system, such as memory
leaks, buffer overflows, and off by one errors. Basic black-box fuzzing on an
embedded system will require some fuzzing harness \citep{Eisele_et_al_2022} and
some method of detecting a fault, such as performing a liveness check
\citep{Yun_2022}.

Compared to black-box fuzzing, white-box fuzzing involves targeted test case
generation through static program analysis techniques, generating a test case
to match every statically identified code path. Microsoft have had success
using white-box fuzzing to identify difficult bugs that were missed by
black-box fuzzing \citep{Godefroid_2012}. However, symbolic execution
techniques used in white-box fuzzing can become unfeasably computationally
expensive for larger projects \citep{Krishnamoorthy_2010}.

Grey-box fuzzing is a middle ground between black-box and white-box fuzzing.
Grey-box fuzzing relies on the fuzzer receiving feedback regarding code
coverage for each generated test-case to mutate and generate further test
cases. This approach allows it to find code paths faster than black-box
testing, but without requiring any static code analysis \citep{Yun_2022}.

Grey-box fuzzing of a program can be easily implemented for application (i.e
non-embedded) software using popular fuzzers like AFL. AFL provides a library
that is linked into the program at compile time, along with several sanitisers,
to instrument the program. This allows AFL to receive coverage information from
the running program during fuzzing \citep{AFL_2019}. Embedded systems often run on
constrained environments, where running the fuzzer on the target hardware would
be unfeasible \citep{Yun_2022}.

Attempts to solve this problem focus either on using a fuzzer on a general
purpose computer, testing a program running on target hardware, or in an
emulated environment \citep{Eisele_et_al_2022}. Running in an emulated
environment allows easy inspection of the SUT by the fuzzer, and potentially
faster running and parallel tests \citep{Eisele_et_al_2022}. However, emulating
embedded systems correctly is a hard problem, and due to the diversity in
operating systems, hardware, peripherals etc. often means that development
effort spent on emulating one system cannot be easily transferred to another.

Yun et al. note that most embedded systems fuzzers rely on emulation
\citep{Yun_2022}. However, most bugs found through emulation still need to be
validated on hardware, and so being able to run the fuzz tests directly on the
target hardware is preferable \citep{Eisele_et_al_2022}.

During the development of an embedded system, engineers often require access to
representative development hardware to effectively design and write software.
Often, waiting for prototype hardware to start software development does not
align with business deadlines. The use of emulators improves enables engineers
to write embedded software without access to development hardware, improving
productivity and reducing development time.

Existing research into embedded systems fuzzing often focuses on its
cybersecurity applications and benefits. However, fuzz testing can also be an
effective method for general verification of software. AdaCore provide a fuzz
testing tool called GNATfuzz, which enables subprogram level fuzz testing as a
supplement to unit testing for Ada and SPARK embedded software
\citep{gnatfuzz}. By isolating subprograms and building isolated fuzz test
executables in a manner similar to a unit testing framework, GNATfuzz removes
the need to be able to run the full program under a fuzzer, and thus the need
for an emulator or target hardware. However, the effectiveness of this approach
is reliant on Ada's extended runtime constraint checking when compared to C
\citep{gnatfuzz}. Furthermore, subprogram level fuzzing is less able detect
more complex issues resulting from interactions with hardware peripherals and
state.

While research into the fuzz testing of embedded systems has been increasing
year by year \citep{Yun_2022}, there are few generic solutions
\citep{Eisele_et_al_2022}. The two main challenges to embedded system fuzzing
when compared to desktop or server systems remain the variety in CPU
architectures in embedded systems, and the lack of an operating system such as
linux for bare metal systems \citep{Eisele_et_al_2022}. Currently, the
availability and ease of use of fuzzing tooling for embedded systems does not
match that of desktop applications.

\citet{IOTFuzzer_2018} implemented IoTFuzzer, an automated black box fuzzing
framework that conduct protocol guided fuzzing on the communication interfaces
of Internet of Things (IoT) devices. IoTFuzzer performs dynamic analysis on the companion
application to the IoT device to identify the methods for creating valid
communication messages to the device, without needing to reverse engineer the
protocol or access to the binary file loaded on the IoT device. This approach
is effective in identifying vulnerabilities in IoT devices, where firmware is
often not available. However, the tool developed has no real use case in other
classes of embedded devices, such as industrial control systems or safety
critical software, where there is unlikely to be a companion android
application that implements the protocol over the communication interface.
The study does show the effectiveness of using a protocol guided
fuzzer on a communication interface to discover memory errors. Specifically,
they identified the ability to run data generated by the fuzzer through the same
cryptographic functions used in the application to allow the fuzzer to bypass
the barrier of message encryption. Standard fuzzers struggle with common
protocol features, like encryption, authentication, or message validity checks,
because mutating the input data will invalidate a checksum or render a message
unable to be decrypted correctly \citep{Fuzztruction_2023}.

\citet{Muench_2018} investigated challenges in embedded fuzzing, and reviews
the potential effects of memory corruption bugs on embedded systems.
They identify how to detect different categories of faults through methods such
as liveness tests. They outline different strategies to fuzzing embedded
systems, such as native, partial emulation, and full emulation. Partial
emulation is where the firmware runs in an emulator, and the peripheral devices
are either modelled in some program, or the memory forwarded to the hardware
peripherals. They conducted an experiment to compare different fuzzing
strategies, and found full emulation to be the most successful in detecting
different categories of memory corruption bugs. They also found that fuzzing
against a fully emulated target is significantly faster than fuzzing against a
native device. However, they acknowledge the limited availability of emulators
which include full peripheral emulation, and identify peripheral modelling with
partial emulation as a good compromise between performance and the availability
of both emulators and hardware.

\citet{Borsig_2020} investigated different fuzzing techniques for ESP32
microcontrollers, which are commonly used for IoT devices. They carried out
blackbox fuzzing of a simple http server application running on hardware, and
detected crashes by monitoring the serial debug for a fault message. They found
this to be the simplest method for fuzzing an ESP32, but also was very
inefficient for triggering bugs. They also carried out whitebox coverage guided
fuzzing with the HONGGFUZZ coverage guided fuzzer \citep{Honggfuzz}, both on
hardware and using an adapted QEMU emulator. For coverage guided fuzzing on
hardware, the same liveness check was used as blackbox fuzzing. Coverage
information of basic block execution was collected by compiling the binary with
additional instrumentation that could run on hardware and fed to HONGGFUZZ over
a JTAG interface. \citet{Borsig_2020} found that using the coverage guided
fuzzer improved the efficiency of the fuzzing to find bugs, but slowed down the
fuzzing execution when compared to blackbox fuzzing. Given the major drawback
to whitebox fuzzing is the availability of the source code to compile in
instrumentation, they concluded that whitebox on target fuzzing would be an
excellent process for testing ESP32 applications as part of agile development.
When trying to fuzz testing using the modified QEMU emulator,
\citet{Borsig_2020} had difficulty emulating the wifi module integrated into
the ESP32 chip. For whitebox fuzzing, they were able to compile the application
to use an ethernet driver provided by QEMU, rather than the hardware wifi
module. However, for blackbox and greybox fuzzing, they manually located the
code section that handled the wifi driver and manually instructed the fuzzer to
insert input data at that location, fuzzing specific sections of the
application. Overall, they concluded that greybox fuzzing using QEMU would be
an effective tool for security analysts looking to fuzz test specific sections
of ESP32 firmware, such as communication stacks \citep{Borsig_2020}.

\citet{Eisele_2022} aims to investigate on target coverage guided fuzzing. They
proposed using the GNU Debugger (GDB) and hardware breakpoints as an
architecture and source code agnostic method of collecting feedback for a
coverage guided fuzzer. Given the limited number of hardware breakpoints
avaiable on embedded systems, They propose several algorithms for selecting
their location for generating feedback. They present initial results, which
show that even with a small number of breakpoints, all their strategies gain
greater coverage overall compared to blackbox fuzzing. They concede that
emulation based fuzzing is likely to produce better results than their method.
However, they state the aim of debugger driven fuzzing is to make coverage
guided fuzz testing easier to conduct for embedded devices, with an assumption
that setting up and running emulation based coverage guided fuzzing for
embedded systems is too complex.

\citet{Beckmann_2023} proposed an alternative method for on target coverage
guided fuzzing, making use of the tracing facilities on modern Arm Cortex-M
microcontrollers to stream coverage information back to the fuzzer. They use
the Serial Wire Debug interface to periodically sample the value of the Program
Counter (PC) on the target, which they used to generate instruction coverage.
Using this technique alone gave worse fuzzing efficiency compared to a blackbox
fuzzer. The fuzzer generated "false positive" inputs, where because not every
instruction was sampled, some semanitically different inputs could be
considered identical. To combat this, they proposed several improvements. One
was to configure the tracing interface to notify upon entry and exit from an
interrupt handler, during which instruction coverage feedback could be ignored.
However, the most effective modification was to make use of hardware
breakpoints to validate any new coverage identified by the fuzzer. After the
fuzzer identified new coverage, a breakpoint would be set at that instruction,
and the input re-run. If the breakpoint was hit and the target halted, then the
coverage was valid. \citet{Beckmann_2023} concluded that their methodology
outperforms on target blackbox fuzzing, providing a reasonable trade-off
between fuzzing speed and effectiveness.

\citet{Maier_2019} developed a tool called UnicoreFuzz for fuzzing operating
system kernel code by running the kernel code using an emulator. Traditional
coverage guided fuzzers rely on feedback mechanisms provided by the kernel, and
using the host operating system as both the fuzzer target and to run the fuzzer
means crashes resulting from fuzz testing would stop the fuzzer.
\citet{kAFL_2017} had previously tried to solve this problem through fuzzing an
operating system kernel running in a separate, virtualised environment, making
use of hardware virtualisation tracing features to gather feedback for the
fuzzer. UnicoreFuzz was built on top of a tool called UnicornAFL
\citep{Maier_2019}. Unicorn is a framework for building emulators, which builds
on top of the instruction set emulation capabilities of QEMU \citep{Unicorn}.
UnicornAFL is a patched version of Unicorn which allows rehosted binaries to be
run under American Fuzzy Lop (AFL), a popular coverage guided fuzzing tool
\citep{UnicornMode, AFL_2019}.
\citet{Maier_2019} focuses on emulating and fuzzing parser code in the kernel,
as parser code usually does not have hardware dependencies, and they
acknowledge modelling hardware peripherals is not an easy task in unicorn.
UnicoreFuzz uses gdb to dump register and memory data at a breakpoint, and then
loads the dumped state into UnicornAFL, allowing the code beginning at the
breakpoint to be fuzzed with the emulator. \citet{Maier_2019} found that while
the performance of UnicoreFuzz was worse than other methods, it was able to
fuzz test any code on any hardware architecture supported by unicorn. Due to
the similarity in constraints between kernel and embedded software, They
posited that porting UnicoreFuzz to embedded operating systems would be viable,
so long as the embedded processor had a debug interface that could export pages
of memory and register values.

UnicoreFuzz was able to fuzz sections of software with no hardware interaction.
However, this ignores the fact that all embedded software programs will have
dependencies on hardware peripherals. However a series of developments have
been made to enable generic rehosting of firmware using the unicorn emulator.

\citet{HALucinator_2020} developed HALucinator, a tool for firmware rehosting
through emulating the hardware abstraction layer. Embedded software typically
relies on a hardware abstraction layer (HAL) to interact with hardware
peripherals. For example, to set the value of a GPIO pin on an STM32 chip, you
would call the \lstinline{HAL_GPIO_WritePin} HAL function \citep{stm32hal}.
This function then handles writing the value to the correct memory location
(MMIO) for that chip to set the GPIO, abstracting the hardware specific
implementation from the functionality. HALucinator parses HAL libraries to
provide a high level emulation (HLE) environment on top of QEMU by assigning
abstract peripheral models to HAL functions in the binary
\citep{HALucinator_2020}. This allows firmware to be run on the emulator
interactively, as well as under a fuzzer like AFL. HALucinator has a number of
prerequisites. The firmware needs to make use of a HAL library for all hardware
interaction. The HAL library either needs to already be supported, or the
handler functions for the library need to be implemented. This is a manual
process, but when completed can be reused for any device using that HAL
library. There also needs to be valid peripheral models implemented for all the
HAL functions used. \citet{HALucinator_2020} demonstrated the use of
HALucinator for fuzzing and dynamic analysis using CPUs and HALs from three
different vendors, using it to detect security bugs in firmware samples.

\citet{Clements_2021} extended HALucinator to work with systems that use the
VxWorks real time operating system (RTOS) as a case study. VxWorks is a
commercial RTOS that is used in many safety critical and space applications.
RTOSes often have their own hardware abstractions, and make use of Board
Support Packages (BSP) to adapt the core RTOS code to different hardware.
While \citet{Clements_2021} successfully run three different VxWorks firmwares
on the emulator, the process for doing so was involved, and required extensions
and modifications to the original HALucinator tool. However, they do review
their original process and outline an approach for rehosting other RTOSes with
HALucinator.

\citet{Chen_2022} investigated a novel approach to fuzzing Real Time Operating
Systems (RTOS) which involves slicing a single program into its constituent
tasks and construct a call graph of program based on critical functions such as
external data entrypoints. Each tailored execution tree is was then fuzzed
separately using a UnicornAFL based emulator. The tool is able to detect and
skip "input-irrelevant" function calls as well code that is "emulation-hard",
such as HAL functions. The tool focuses on code paths that handle input data,
so there are minimal side effects from ignoring these functions.

While SFuzz is focused fuzzing a single input interface of a given firmware,
Fuzzware is a tool that takes a different approach by considering all memory
available to the firmware as input \citep{Fuzzware_2022}. Fuzzware expands upon
HALucinator, but rather than using the HAL as the boundary for the fuzzer and
the SUT, it models the MMIO, such that each MMIO access uses fuzzer input.
Fuzzware is also based on UnicornAFL, and uses symbolic execution to apply
"access models" to MMIO locations. These access models guide the fuzzer to only
generate meaningful values for memory accesses. For example, in the case where
an MMIO location is only read and compared to a magic number, the symbolic
execution engine will tell Fuzzware to use a "constant" access model for that
MMIO, with the magic number as the constant value. Alternatively, if an MMIO
register is accessed, and only certain bits of the register are used (a common
occurrence when working with embedded software), Fuzzware will use the
"bitfield" access model, and so the fuzzer will only generate input data for
the bits used by the firmware. This massively reduces the "input overhead" of
the fuzzer, i.e. input data that isn't actively used by the firmware during the
fuzz test. \citet{Fuzzware_2022} show that this approach makes the fuzzer much
more effective at discovering coverage than other rehosting-based fuzzing
tools.

AFL traditionally expects the program being fuzzed to require a flat binary input.
While Fuzzware removes a lot of "input overhead", it reinterprets the flat
input from AFL as a series of MMIO accesses, but AFL still only has one input
stream. This can result in the input being hard to mutate effectively, as
changing a bit could result in a different execution path in the program, and
so changing the semantics of later bits in the stream.
Hoedur \citep{Hoedur_2023} is an extension of Fuzzware, which includes a novel
multi-stream fuzzer, rather than AFL, such that each MMIO access consumes input
data from its own input stream. This greatly improves the ability of the fuzzer
to mutate MMIO input data. Unlike HALucinator before them, both Fuzzware and
Hoedur perform automated firmware rehosting, as the only manual work needed to
fuzz a firmware is knowledge and configuration of the firmwares memory map and
architecture. Generating data for MMIO locations means that modelling
peripherals, like HALucinator, is not necessary. However, this means that
unlike HALucinator, firmware run on Hoedur or Fuzzware cannot be run
interactively, it must be run under the fuzzer. While both are based on
Unicorn, which supports multiple target architectures, Fuzzware and Hoedur are
only currently available on ARM Cortex-M, chosen for its popularity, and use in
other state of the art fuzzers to allow fair comparisons. Given Hoedur's
independent input streams for each MMIO, \citet{Hoedur_2023} identified the
integration of specialized grammar fuzzers into Hoedur as an area for future
work. This would further reduce "input overhead" on communication interfaces,
as grammar fuzzers are better able to correctly handle encryption or packet
validation. These are common features of embedded communication protocols, as
demonstrated by IoTFuzzer \citep{IOTFuzzer_2018}.

Additionally, \citet{Zhang_2024} conducted a comprehensive survey of existing
protocol fuzzing techniques and found that domain specific protocols are
underrepresented in protocol fuzzing research. They identified the development
of protocol fuzzers for satellite communications as a research opportunity.

Fuzztruction \citep{Fuzztruction_2023} moves away from AFL entirely to resolve
these issues surrounding encryption/checksums by creating a new type of fuzzer
that mutates not just the input data, but the code that generates the input
data. This enables the tool to make use of the domain knowledge encoded in some
generator software, without needing complex program analysis or a human domain
expert. Fuzztruction is proposed in part as an alternative to grammar based
techniques for generating well structured inputs in order to reach deeper into
the state space of a program \citep{Fuzztruction_2023}. Grammar fuzzing
requires pre-existing knowledge of the program being tested, where as
Fuzztruction does not. This makes Fuzztruction more useful in situations where
only blackbox and greybox testing can be carried out, such as for cybersecurity
applications \citep{Fuzztruction_2023}. Several processes, such as identifying
instructions that read/write to/from memory, are carried out on the generator
program to ensure only impactful mutations are applied to the program.
\citet{Fuzztruction_2023} also proposed using Fuzztruction in combination with
a traditional coverage guided fuzzer, such as AFL++. In this configuration,
Fuzztruction and AFL++ are both used to generate input data, with a scheduling
component that enables AFL++ to mutate inputs found by Fuzztruction.
Fuzztruction was compared against existing state of the art general purpose
fuzzers: AFL++, SymCC and Weizz; and was shown to outperform all of them in
terms of coverage over time. While the result is very promising, the fuzzer is
currently not integrated with any rehosting based tools, like unicorn, and so
is unable to fuzz embedded software.

\citet{Seidel_2023} investigated techniques for creating faster firmware
fuzzers by running emulated arm instructions on native arm64 hardware. They
implemented SafireFuzz, which used high level emulation techniques from
HALucintor \citep{HALucinator_2020}, and relied on the fact that the ARM
Thumb-v2 instruction set implemented in embedded microcontrollers (ARM
Cortex-M) is available as an execution state in application level processors
(ARM Cortex-A). They implemented a dynamic binary rewriting engine to translate
basic blocks in firmware into compatible native arm64 instructions. This
near-native execution greatly outperformed existing unicorn based rehosting
fuzzers, like HALucinator \citep{HALucinator_2020} and Fuzzware
\citep{Fuzzware_2022}, in terms of coverage over time.

\section{Fuzz Testing in the Space Industry}

\citet{Gutierrez_2021} conducted black-box fuzz testing aginst the Suchai
CubeSat flight software \citep{Suchai_FSW}. The Suchai FSW was designed to be
able to run on Cubesat OBCs, such as the GomSpace Nanomind, microcontrollers
such as ESP32's, or both embedded and desktop computers running Linux. Due to
the flexibility in the target hardware, \citet{Gutierrez_2021} were able to
run both the flight software and the fuzzer natively on a general purpose linux
computer, without any emulation software like unicorn or QEMU. The Suchai FSW
used a Cubesat Space Protocol (CSP) communication interface for receiving
commands. \citet{Gutierrez_2021} implemented a black-box fuzzer that sends
random data to the CSP command handler using four different strategies, which
constrain input data to different levels of correctness to target different
aspects of the FSW. For example, the first strategy is to generate random
commands, most of which should be safely rejected by the command handler, while
the third strategy is to generate syntatcially valid sets of commands and
parameters, but with randomised parameter values. Their implementation doesn't
seem to have a strategy that randomised the structure of a CSP packet, so it is
assumed that the CSP implmentation isn't fuzz tested in their work. However, as
the Suchai FSW uses libCSP as an external library to implement the protocol,
which may have infulenced their decision to not fuzz test the protocol stack.
\citet{Gutierrez_2021} showed that using their black-box fuzz testing
techniques against the Suchai FSW as part of an agile development process
enabled them to find and resolve bugs in the software that had not been
identified with other testing techniques, and so prove the utility of fuzz
testing flight software. % FIXME despite the simple fuzzing strategy and testing the embedded software binary.

\citet{Scharnowski_2023} presented a case study where they used Fuzzware
\citep{Fuzzware_2022} to fuzz test three CubeSat FSW images that run on ARM
Cortex-M STM32F4 microcontrollers. This showed Fuzzware to be effective at
identifying bugs in flight software, and demonstrated different methods of
configuring Fuzzware to improve fuzzing effectiveness. The specific focus of
these configurations in a flight software context was to enable the fuzzer to
correctly move through the complex boot process present in the satellite
firmware, to be able to fuzz the application. These configurations included
manually specifying MMIO accesses to move through the boot section,
snapshotting the firmware state after booting to allow future runs to fuzz test
from that state, or extending Fuzzware to implement AFL++ features not
previously implemented in UnicornAFL \citep{Scharnowski_2023}. In addition to
the complexity of satellite FSW boot processes, another challenge identified
was that Fuzzware's MMIO based approach does not automatically analyse
interrupt timing requirements, which can make it difficult for the fuzzer to
reach code that have dependencies on hardware features like DMA (direct memory
access). Ultimately, they conclude that while their methodology was effecitive,
the current need for a human expert to configure the fuzzer to be effective
makes the use of Fuzzware less feasible as part of continuous integration of
satellite firmware \citep{Scharnowski_2023}.

\citet{Willbold_2024} conducted an investigation into the application of
current state of the art fuzz testing methodologies in the context of security
analysis of satellite flight software. They identify the attack surfaces of
satellites, such as telecommands from the ground, or components integrated in
the satellite sufferring from supply chain attacks. They also outline
challenges with fuzz testing specific to satellites, including the complexity
of satellite computer boot processes (discussed previously by
\citet{Scharnowski_2023}), and the difficulty of on target fuzzing. They
identify that most fuzzers use crashes as the measure of failure, and state
that for satellite software a crash/reboot may not be the most problematic
outcome. Examples of a more severe outcomes include triggering end of life
procedures such as deorbiting and battery passivation, modifying orbit
parameters, disabling radios, etc. They also comment on the general complexity
of software systems in satellites, with most being highly integrated bespoke
distributed systems with unique combinations of peripherals and payloads. This
makes it difficult to build reusable emulators. Other industries with similar
levels of complexity, such as automotive and aviation, often have larger
resources for a single project, which makes building and maintaining emulators
more cost effective. \citet{Willbold_2024} conducted three case studies using
different fuzzing methodologies against different flight software targets.

The first case study used a technique called subsystem extraction, against a
target software known as "Flying Laptop". The Flying Laptop FSW was an RTEMS
system running on a LEON3 processor, which uses the SPARC instruction set. The
telecommand (TC) processing subsystem in the flight software was manually
identified and extracted into a Linux executable, that could be run inside an
emulated SPARC Linux environment. Creating a Linux executable enabled the use
of general purpose fuzzing tools like AFL++, rather than firmware specific
fuzzing tools. This approach was limited to fuzzing the TC processing
subsystem, which in some usecases may be beneficial as it avoided difficulties
with the complex boot sequence, and removed dependencies on hardware. However,
those parts of the FSW would not verified. Furthermore, porting the FSW
components to be able to run on linux, which made use of RTEMS primitives and
had many other low level incompatible dependencies, was lot of work and as such
this case study was not completed \citep{Willbold_2024}.

The second case study use the flight software from ESA's OPS-SAT CubeSat, and
used a technique \citet{Willbold_2024} called full system emulation with
persitent mode fuzzing. The OBS-SAT FSW ran on an AVR32 microcontroller, and
\citet{Willbold_2024} had to create an AVR32 instruction set emulator in QEMU
(AVR32 instruction set was not supported by unicorn \citep{Unicorn}). This,
again, was a large amount of work. Though \citet{Willbold_2024} justified the
investment as only needing to be done once, and they published their
implementation for others to use. In this case study, hardware peripherals like
sensors and actuators were modelled to provide constant values. The goal of
this case study was to complete a minimal working emulator that would enable
the firmware to receive and process TCs during fuzz testing. Therefore, as with
the first case study, this method was only able to produce useful results for
the TC handling software components, and fuzzing produced basic block coverage
of 76\%, and successfully identified a buffer overflow bug in the software
\citep{Willbold_2024}. In order to improve execution time, the emulator would
only intermittently reboot the firmware between fuzzer inputs. While this
improved the speed of the fuzzing by reducing the overhead of executing the
boot process every iteration, this resulted in some crashes that were not
reproducable due to accumulated state \citep{Willbold_2024}.

The final case study used flight software from the ESTCube-1 CubeSat, and used
an approach \citet{Willbold_2024} called full firmware rehosting. They used
Hoedur \citep{Hoedur_2023} to rehost and fuzz test the FSW. Only required
a small amount of manual work to was required to modify a configuration file in
order for the fuzzing to work correctly. Hoedur was shown to reach 78\% basic
block coverage in the TC handler functions in the ESTCube-1 FSW, and identified
several crashing inputs. The only feature of Hoedur that \citet{Willbold_2024}
identified as lacking was an inability to detect non-crashing faults. However,
they outlined that by marking an area of memory as "read only" in the Hoedur
configuration file, the software would trigger a crash if it wrote to that
location. Using Hoedur was shown to require much less effort than the other
approaches, as well as manage the challenge of fuzzing complex boot processes
in satellite software. \citet{Willbold_2024} conclude that rehosting tools
like Hoedur represent the most promising approach to fuzz testing for satellite
software security analysis.



% 19 papers, any more, we have other references for information:
% - Cratere_2024
% - Farges_2022
% - Godefroid_2012 (whitebox fuzzing for security testing)
% - Krishnamoorthy_2010 (symbolic execution test generation...)
% - Svoboda_2021 (how exploitable is c code)
% - Abdumohasan_2021 (analytical review of cybersecurity for embedded systems)
% - \citet{Hernandez_2022} FirmWire (dynamic analysis of cellular baseband firmware) less relevent maybe?


% We got Willbold using Hoedur
% We got Scharnowski talking about interrupts and DMA being an issues for Fuzzware/Hoedur
% Hoedur, protocol fuzzing, etc.
%


\end{document}
