\documentclass[../report.tex]{subfiles}
\graphicspath{{\subfix{../images}}}
\begin{document}

\section{Software Engineering in the New Space Industry}
% References:
% - Bousedra_2024: policy paper, may be less useful?
% - Denis_2020: paper discussing trends in the space industry, more relevent?
% - Cubesat_Handbook: book with information about designing cubesats, useful for satellite architecture?
% - Cratere_2024: OBC for Cubesats State of the Art

In the past, developing and launching satellites was the domain of large
corporations and governments due to the costs involved. Recently, In order to
take advantage of cheaper access to space (\autoref{sec:motivation}), a new
type of organisation has begun to build and operate space missions.

\citet{Sweeting_2018} defines New Space as
\begin{quote}
    The emergence of a different ethos for space where the established
    aerospace methods and business have been challenged by more entrepreneurial
    private sector by adopting more agile approaches and exploiting the latest
    commercial-off-the-shelf technologies
\end{quote}

\citet{Denis_2020} describes the current market trends of New Space as
"Darwinism in Space". The creation of new markets in the space environments as
a result of the digital transformation has led to a space industry "gold rush",
with large venture capital investment and a "winner takes all" incentive
driving high levels of competition \citep{Denis_2020}. The impact of this is
that New Space companies must design and manufacture more satellites at a
faster rate and for lower cost if they wish to be competitive. These market
conditions have led New Space businesses to become more accepting of risk than
their Big Space counterparts \citep{Cratere_2024}. Therefore, many of the
approaches used by Big Space companies to ensure software correctness, such as
extensive system and integration testing and formal methods, are simply too time
consuming and expensive to be applicable in the New Space environment.


% TODO remove?
% As a result of the business environment, many New Space start ups have
% introduced silicon valley concepts into their businesses, such as "DevOps
% culture" and launching Minimum Viable Product (MVP) CubeSats. Furthermore, as
% these companies transition from start-ups to mature businesses with an aim to be
% profitable, LEAN practices become prevalent, resulting in attempts to reduce
% any "wasteful" or expensive practices \citep{Denis_2020}.


% FIXME should this be cut?
% Therefore, Flight Software needs to be developed in shorter time frames and with
% lower costs. Satellites in low earth orbit have a shorter lifetime due to
% atmospheric drag. CubeSats have a generally high failure rate due to a long
% list of possible failure modes which can cripple a platform, with no chance of
% repair. Some examples might be a solar panel not deploying, a launch vibration
% damaging a critical sensor, or an issue with the thermal management resulting
% in the payload having degraded operations. Often, the correctness of the
% software systems only becomes an issue when all these barriers have been
% passed, and so is a risk that is not considered worth spending time and money
% until later in a programme. Thus, new space companies have a vastly different
% approach to software systems compared with big space companies, and

\section{Satellite Architecture}

Software systems are an essential component of modern satellite designs.
Satellites usually include a number of distributed embedded systems, each
tasked with monitoring and controlling different critical subsystems such as
power, attitude control, communication, typically all controlled by a
central on board computer (OBC).

% TODO include?
% There may be a dedicated guidance navigation and control (GNC) or attitude
% determination and control (ADCS) subsystem which runs complex algorithms using
% data retrieved from sensors like star trackers, rate sensors, magnetometers and
% sun sensors to drive actuators like reaction wheels and magnetorquers in order
% to point the satellite. Pointing is critical for many tasks. Payload operation
% tasks such as imaging require a high degree of accuracy and responsiveness.
% Propulsion manoeuvres, managing thermal loads, power generation (i.e. pointing
% the solar panels at the sun to improve the efficiency) all require an effective
% ADCS subsystem.

The OBC will be connected to many lower power telemetry (TM) nodes, which are
tasked with monitoring temperatures, voltages and currents, and toggling switches
to enable/disable different subsystems. The OBC will log the telemetry reported
by the TM nodes, and if telemetry exceeds limits, handle fault detection,
isolation and recovery (FDIR).

The OBC is also responsible for handling communication with a ground station
via a radio, and so provides the interface between a satellite and the
operator. This interface is commonly referred to as Telemetry and Telecommand
(TMTC). The operator uses the TMTC interface on the OBC to download data from
orbit, schedule payload operations, and respond to problems. On smaller
satellites like CubeSats, the OBC is often also responsible for managing
payload operations.

% TODO include?
% Payload computers (PLC) are common on satellites with complex payloads and are
% responsible for managing and operating whatever instruments are on board for
% delivery of the mission, such as radios, imagers, scientific experiments etc.
% On smaller satellites, like CubeSats where payloads are less complex, the
% responsibilities of the PLC can be handled by the OBC.


\section{Flight Software Development Challenges}

CubeSats projects tend to make more use of commercial-off-the-shelf (COTS)
hardware. However, CubeSat software is often bespoke, and so development costs
shift from hardware to software \citep{Cubesat_Handbook_OBSW}. However, there
are several flight software frameworks, such as NASA's Core Flight System (cFS)
\citep{Nasa_cFS}, or Bright Ascensions Generation One (Gen1) Flight Software
Development Kit (FSDK) \citep{Bal_FSDK}, that aim to reduce the cost and
development time for flight software through code reuse and hardware
abstraction.

A cFS application uses software abstractions of the operating system and
hardware, called the Operating System Abstraction Layer (OSAL) and Platform
Support Package (PSP). This allows correctly written application code to easily
be ported between different hardware architectures such as Arm Cortex-M or
SPARC-V8, and different operating systems like FreeRTOS, RTEMS or Linux
\citep{Nasa_cFS}.

The Gen1 FSDK provides libraries of pre-defined configurable software
"Components", which satisfy common flight software requirements, such as
logging telemetry. These pre-defined components can be composed together with
bespoke components into a "Deployment" which can be compiled for several
different COTS hardware options, such as the AAC-ClydeSpace Kryten, or the
GomSpace Nanomind \citep{Bal_Options}.

\citet{Farges_2022} evaluated the use of Software Frameworks in the space
industry. They find a number of quality related benefits, such as increasing
reliance on standardised communication interfaces like CCSDS Space Packet
Protocol; as well as cost related benefits attributable to code reuse between
satellite missions. However, they also identified risks with relying on software
frameworks, such as potential issues with licenses, and the limited
adaptability of software that is highly coupled to a framework, as implementing
functions that aren't currently supported in the framework can be difficult.

Developing flight software for satellite systems is a complex process due to
the large number of different interfaces and interdependencies in the
architecture. Furthermore, due to the space environment, computers used in
satellite systems can have stringent environmental requirements, such as high
radiation tolerance to reduce the likelihood of single event upsets (SEU), low
power consumption and consideration of thermal management. The embedded
microcontrollers that meet these requirements can be more expensive than those
commonly used for other applications, like in automotive systems or IOT devices.

When writing software for embedded systems there is often a critical dependency
on hardware. Writing drivers for devices using only a datasheet can result in
long periods of rework when hardware is available to test against due to
incorrect information or a misinterpretation. The number of interdependent
systems, the costs of these components, and smaller budgets of new space
companies, results in dedicated engineering hardware required for effective
development of embedded flight software being unavailable. Often engineers are
only able to test with flight hardware, and even then have to fit their
testing into a tight schedule to meet deadlines.

Software development standards, such as MISRA and NASA's the power of ten exist
to provide guidelines for successfully creating correct software, and hopefully
reduce the burden of testing \citep{NASA_10}. However, while applying these
techniques can reduce the occurrence of introducing bugs during development,
they are not a substitute for system verification.

\section{Fuzz Testing} \label{sec:lit-rev:fuzz}

Many software programs use a methodology called fuzz testing to automatically
verify software. Fuzz testing is typically used to identify and resolve
security vulnerabilities for programs running on general purpose computers
\citep{Google_2023}. In its most basic form, fuzz testing, or fuzzing, consists
of generating some input test data and monitoring the response of the
software/system under test (SUT) to this input. If the fuzzer detects the
program has crashed, it saves the generated test data for analysis by an
engineer, and mutates the input data in some way to produce a different result.
This brute force approach is known as blackbox fuzzing, and given enough time
to execute, will uncover many exploitable bugs with the system, such as memory
leaks, buffer overflows, and off by one errors. Basic blackbox fuzzing on an
embedded system will require some fuzzing harness \citep{Eisele_et_al_2022} and
some method of detecting a fault, such as performing a liveness check
\citep{Yun_2022}.

Compared to blackbox fuzzing, whitebox fuzzing involves targeted test case
generation through static program analysis techniques, generating a test case
to match every statically identified code path. Microsoft have had success
using whitebox fuzzing to identify difficult bugs that were missed by
blackbox fuzzing \citep{Godefroid_2012}. However, symbolic execution
techniques used in whitebox fuzzing can become unfeasibly computationally
expensive for larger projects \citep{Krishnamoorthy_2010}.

Greybox fuzzing is a middle ground between blackbox and whitebox fuzzing.
Greybox fuzzing relies on the fuzzer receiving feedback regarding code coverage
for each generated test-case to mutate and generate further test cases. This
approach allows it to find code paths faster than blackbox testing, but without
requiring any static code analysis \citep{Yun_2022}. Greybox fuzzing can be
easily implemented for application (non-embedded) software using popular
fuzzers like American Fuzzy Lop (AFL). AFL provides a library that is linked
into the program at compile time, along with several sanitisers, to instrument
the program. This allows AFL to receive coverage information from the running
program during fuzzing \citep{AFL_2019}. Embedded systems often run on
constrained environments, where running the fuzzer on the target hardware would
be unfeasible \citep{Yun_2022}.

Research into the fuzz testing of embedded systems has been increasing
year by year \citep{Yun_2022}, but there are few generic solutions
\citep{Eisele_et_al_2022}. The two main challenges to embedded system fuzzing
when compared to desktop or server systems remain the variety in CPU
architectures in embedded systems, and the lack of an operating system such as
Linux for bare metal systems \citep{Eisele_et_al_2022}.

Attempts to solve these problem focus on using a fuzzer on a general purpose
computer, and testing against a program running on target hardware or in an
emulated environment \citep{Eisele_et_al_2022}. Running in an emulated
environment allows easy inspection of the SUT by the fuzzer, and potentially
faster running and parallel tests \citep{Eisele_et_al_2022}. \citet{Yun_2022}
noted in their survey of embedded system fuzzers that most rely on emulation.
However, emulating embedded systems correctly is a hard problem. The
diversity in operating systems, hardware and peripherals often means that
development effort spent on emulating one system cannot be easily transferred
to another. However, according to \citet{Eisele_et_al_2022}, being able to run
the fuzz tests directly on the target hardware is preferable because most bugs
found through emulation still need to be validated on hardware. The use of
emulators can enable engineers to write embedded software without access to
development hardware, improving productivity and reducing development time.

Existing research into embedded systems fuzzing often focuses on its
cybersecurity applications and benefits. However, fuzz testing can also be an
effective method for general verification of software. AdaCore provide a fuzz
testing tool called GNATfuzz, which enables subprogram level fuzz testing as a
supplement to unit testing for Ada and SPARK embedded software
\citep{gnatfuzz}. By isolating subprograms and building isolated fuzz test
executables in a manner similar to a unit testing framework, GNATfuzz removes
the need to be able to run the full program under a fuzzer, and thus the need
for an emulator or target hardware. However, the effectiveness of this approach
is reliant on Ada's extended runtime constraint checking when compared to C
\citep{gnatfuzz}. Furthermore, subprogram level fuzzing is less able detect
more complex issues resulting from interactions with hardware peripherals and
state.

\citet{IOTFuzzer_2018} implemented IoTFuzzer, an automated black box fuzzing
framework that conducts protocol guided fuzzing on the communication interfaces
of Internet of Things (IoT) devices. IoTFuzzer performs dynamic analysis on the companion
application to the IoT device to identify the methods for creating valid
communication messages to the device, without needing to reverse engineer the
protocol or access to the binary file loaded on the IoT device. This approach
is effective in identifying vulnerabilities in IoT devices, where firmware is
often not available. However, the tool developed has no real use case in other
classes of embedded devices, such as industrial control systems or safety
critical software, where there is unlikely to be a companion android
application that implements the protocol over the communication interface.
The study does show the effectiveness of using a protocol guided
fuzzer on a communication interface to discover memory errors. Specifically,
they identified the ability to run data generated by the fuzzer through the same
cryptographic functions used in the application to allow the fuzzer to bypass
the barrier of message encryption. Standard fuzzers struggle with common
protocol features, like encryption, authentication, or message validity checks,
because mutating the input data will invalidate a checksum or render a message
unable to be decrypted correctly \citep{Fuzztruction_2023}.

\citet{Muench_2018} investigated challenges in embedded fuzzing, and reviews
the potential effects of memory corruption bugs on embedded systems.
They identify how to detect different categories of faults through methods such
as liveness tests. They outline different strategies to fuzzing embedded
systems, such as native, partial emulation, and full emulation. Partial
emulation is where the firmware runs in an emulator, and the peripheral devices
are either modelled in some program, or the memory forwarded to the hardware
peripherals. They conducted an experiment to compare different fuzzing
strategies, and found full emulation to be the most successful in detecting
different categories of memory corruption bugs. They also found that fuzzing
against a fully emulated target is significantly faster than fuzzing against a
native device. However, they acknowledge the limited availability of emulators
which include full peripheral emulation, and identify peripheral modelling with
partial emulation as a good compromise between performance and the availability
of both emulators and hardware.

\citet{Borsig_2020} investigated different fuzzing techniques for ESP32
microcontrollers, which are commonly used for IoT devices. They carried out
blackbox fuzzing of a simple http server application running on hardware, and
detected crashes by monitoring the serial debug for a fault message. They found
this to be the simplest method for fuzzing an ESP32, but also was very
inefficient for triggering bugs. They also carried out whitebox coverage guided
fuzzing with the HONGGFUZZ coverage guided fuzzer \citep{Honggfuzz}, both on
hardware and using an adapted QEMU emulator. For coverage guided fuzzing on
hardware, the same liveness check was used as blackbox fuzzing. Coverage
information of basic block execution was collected by compiling the binary with
additional instrumentation. The binary could then be run on the hardware and
feed coverage data to HONGGFUZZ over a JTAG interface. \citet{Borsig_2020}
found that using the coverage guided fuzzer improved the efficiency of finding
bugs with the fuzzer, but reduced the speed of fuzzer execution when compared
to blackbox fuzzing. Given the major drawback to whitebox fuzzing is the
availability of the source code to compile in instrumentation, they concluded
that whitebox on target fuzzing would be an excellent process for testing ESP32
applications as part of agile development. When fuzzing using the modified QEMU
emulator, \citet{Borsig_2020} had difficulty emulating the Wi-Fi module
integrated into the ESP32 chip. For whitebox fuzzing, they were able to compile
the application to use an Ethernet driver provided by QEMU, rather than the
hardware Wi-Fi module. However, for blackbox and greybox fuzzing, they manually
located the code section that handled the Wi-Fi driver and manually instructed
the fuzzer to insert input data at that location, fuzzing specific sections of
the application. Overall, they concluded that greybox fuzzing using QEMU would
be an effective tool for security analysts looking to fuzz test specific
sections of ESP32 firmware, such as communication stacks \citep{Borsig_2020}.

\citet{Eisele_2022} aimed to investigate on target coverage guided fuzzing.
They proposed using the GNU Debugger (GDB) and hardware breakpoints as an
architecture and source code agnostic method of collecting feedback for a
coverage guided fuzzer. Given the limited number of hardware breakpoints
available on embedded systems, they proposed several algorithms for selecting
their location for generating feedback. They presented initial results, which
showed that even with a small number of breakpoints, all their strategies gain
greater coverage overall compared to blackbox fuzzing. They conceded that
emulation based fuzzing is likely to produce better results than their method.
However, they state the aim of debugger driven fuzzing is to make coverage
guided fuzz testing easier to conduct for embedded devices, with an assumption
that setting up and running emulation based coverage guided fuzzing for
embedded systems is too complex.

\citet{Beckmann_2023} proposed an alternative method for on target coverage
guided fuzzing, making use of the tracing facilities on modern Arm Cortex-M
microcontrollers to stream coverage information back to the fuzzer. They use
the Serial Wire Debug interface to periodically sample the value of the Program
Counter (PC) on the target, which they used to generate instruction coverage.
Using this technique alone gave worse fuzzing efficiency compared to a blackbox
fuzzer. The fuzzer generated "false positive" inputs, where because not every
instruction was sampled, some semantically different inputs could be
considered identical. To combat this, they proposed several improvements. One
was to configure the tracing interface to notify upon entry and exit from an
interrupt handler, during which instruction coverage feedback could be ignored.
However, the most effective modification was to make use of hardware
breakpoints to validate any new coverage identified by the fuzzer. After the
fuzzer identified new coverage, a breakpoint would be set at that instruction,
and the input re-run. If the breakpoint was hit and the target halted, then the
coverage was valid. \citet{Beckmann_2023} concluded that their methodology
outperforms on target blackbox fuzzing, providing a reasonable trade-off
between fuzzing speed and effectiveness.

\citet{Maier_2019} developed a tool called UnicoreFuzz for fuzzing operating
system kernel code by running the kernel code using an emulator. Traditional
coverage guided fuzzers rely on feedback mechanisms provided by the kernel, and
using the host operating system as both the fuzzer target and to run the fuzzer
means crashes resulting from fuzz testing would stop the fuzzer.
\citet{kAFL_2017} had previously tried to solve this problem through fuzzing an
operating system kernel running in a separate, virtualised environment, making
use of hardware virtualisation tracing features to gather feedback for the
fuzzer. UnicoreFuzz was built on top of a tool called UnicornAFL
\citep{Maier_2019}. Unicorn is a framework for building emulators, which builds
on top of the instruction set emulation capabilities of QEMU \citep{Unicorn}.
UnicornAFL is a patched version of Unicorn which allows rehosted binaries to be
run under AFL++, a popular coverage guided fuzzing tool that is an extended fork of AFL
\citep{UnicornMode, AFL_2019, AFLplusplus}.
\citet{Maier_2019} focused on emulating and fuzzing parser code in the kernel,
as parser code usually does not have hardware dependencies, and they
acknowledge modelling hardware peripherals is not an easy task in Unicorn.
UnicoreFuzz uses GDB to dump register and memory data at a breakpoint, and then
loads the dumped state into UnicornAFL, allowing the code beginning at the
breakpoint to be fuzzed with the emulator. \citet{Maier_2019} found that while
the performance of UnicoreFuzz was worse than other methods, it was able to
fuzz test any code on any hardware architecture supported by Unicorn. Due to
the similarity in constraints between kernel and embedded software, They
posited that porting UnicoreFuzz to embedded operating systems would be viable,
so long as the embedded processor had a debug interface that could export pages
of memory and register values.

UnicoreFuzz was able to fuzz sections of software with no hardware interaction.
However, this ignores the fact that all embedded software programs will have
dependencies on hardware peripherals. Recently, a series of developments have
been made to enable generic rehosting based fuzz testing of firmware.

\citet{HALucinator_2020} developed HALucinator, a tool for firmware rehosting
through emulating the hardware abstraction layer (HAL). Embedded software
typically relies on a HAL to interact with hardware peripherals. For example,
to set the value of a GPIO pin on an STM32 chip, you would call the
\lstinline{HAL_GPIO_WritePin} HAL function \citep{stm32hal}. This function then
handles writing the value to the correct memory location (MMIO) for that chip
to set the GPIO, abstracting the hardware specific implementation from the
functionality. HALucinator parses HAL libraries to provide a high level
emulation (HLE) environment on top of QEMU by assigning abstract peripheral
models to HAL functions in the binary \citep{HALucinator_2020}. This allows
firmware to be run on the emulator interactively, as well as under a fuzzer
like AFL++. HALucinator has a number of prerequisites. The firmware must use a
supported HAL library for all hardware interaction, or handler functions for
the HAL need to be implemented. This is a manual process, but when completed
can be reused for any device using that HAL library. There also needs to be
valid peripheral models implemented for all the HAL functions used.
\citet{HALucinator_2020} demonstrated the use of HALucinator for fuzzing and
dynamic analysis using microcontrollers and HALs from three different vendors,
using it to detect security bugs in firmware samples.

\citet{Clements_2021} extended HALucinator to work with systems that use the
VxWorks real time operating system (RTOS) as a case study. VxWorks is a
commercial RTOS that is used in many safety critical and space applications.
RTOSes often have their own hardware abstractions, and make use of Board
Support Packages (BSP) to adapt the core RTOS code to different hardware.
While \citet{Clements_2021} successfully ran three different VxWorks firmwares
on the emulator, the process for doing so was involved, and required extensions
and modifications to the original HALucinator tool. However, they do review
their original process and outline an approach for rehosting other RTOSes with
HALucinator.

\citet{Chen_2022} investigated a novel approach to fuzzing systems that use
real time operating systems, called SFuzz. SFuzz slices a single program into
its constituent tasks and constructs a call graph of the program based on critical
functions such as external data entry points. Each tailored execution tree is
then fuzzed separately using a UnicornAFL based emulator. SFuzz is able to
detect and skip "input-irrelevant" function calls as well code that is
"emulation-hard", such as HAL functions. SFuzz focused on code paths that
handle input data, so there are minimal side effects from ignoring these
functions.

While SFuzz is focused fuzzing a single input interface of a given firmware,
Fuzzware is a tool that takes a different approach by considering all memory
available to the firmware as input \citep{Fuzzware_2022}. Fuzzware expands upon
HALucinator, but rather than using the HAL as the boundary for the fuzzer and
the SUT, it models the memory mapped input output (MMIO) registers, such that
each MMIO access uses fuzzer input. Fuzzware is also based on UnicornAFL, and
uses symbolic execution to apply "access models" to MMIO locations. These
access models guide the fuzzer to only generate meaningful values for memory
accesses. For example, in the case where an MMIO location is only read and
compared to a magic number, the symbolic execution engine will tell Fuzzware to
use a "constant" access model for that MMIO, with the magic number as the
constant value. Alternatively, if an MMIO register is accessed, and only
certain bits of the register are used (which is a common occurrence when
working with embedded software), Fuzzware will use the "bitfield" access model.
This means the fuzzer will only generate input data for the bits used by the
firmware. This massively reduces the "input overhead" of the fuzzer: meaning
input data that isn't actively used by the firmware during the fuzz test.
\citet{Fuzzware_2022} show that this approach makes the fuzzer much more
effective at discovering coverage than other rehosting-based fuzzing tools.

AFL++ traditionally expects the program being fuzzed to require a flat binary input.
While Fuzzware removes a lot of "input overhead", it reinterprets the flat
input from AFL++ as a series of MMIO accesses, but AFL++ still only has one input
stream. This can result in the input being hard to mutate effectively, as
changing a bit could result in a different execution path in the program, and
so changing the semantics of later bits in the stream.
Hoedur \citep{Hoedur_2023} is an extension of Fuzzware, which includes a novel
multi-stream fuzzer, rather than AFL++, such that each MMIO access consumes input
data from its own input stream. This greatly improves the ability of the fuzzer
to mutate MMIO input data. Unlike HALucinator before them, both Fuzzware and
Hoedur perform automated firmware rehosting, as the only manual work needed to
fuzz a firmware is knowledge and configuration of the firmwares memory map and
architecture. Generating data for MMIO locations means that modelling
peripherals, like HALucinator, is not necessary. However, this means that
unlike HALucinator, firmware being run with Hoedur or Fuzzware cannot be run
interactively, it must be run under the fuzzer. While both are based on
Unicorn, which supports multiple target architectures, Fuzzware and Hoedur are
only currently implemented for ARM Cortex-M, which was chosen due its popularity
and use in other state of the art fuzzers to allow for fair comparisons. Given
Hoedur has independent input streams for each MMIO, \citet{Hoedur_2023}
identified the integration of specialized grammar fuzzers into Hoedur as an
area for future work. This would further reduce "input overhead" on
communication interfaces, as grammar fuzzers are better able to correctly
handle encryption or packet validation. These are common features of embedded
communication protocols, as demonstrated by IoTFuzzer \citep{IOTFuzzer_2018}.
Furthermore, \citet{Zhang_2024} conducted a comprehensive survey of existing
protocol fuzzing techniques and found that domain specific protocols are
under-represented in protocol fuzzing research. They identified the development
of protocol fuzzers for satellite communications as a research opportunity.

Fuzztruction \citep{Fuzztruction_2023} aims to resolve these issues surrounding
encryption/checksums by creating a new type of fuzzer that mutates not just the
input data, but the code that generates the input data. This enables the tool
to make use of the domain knowledge encoded in protocol generator software, without
needing complex program analysis or a human domain expert. Fuzztruction is
proposed in part as an alternative to grammar based techniques for generating
well structured inputs in order to reach deeper into the state space of a
program \citep{Fuzztruction_2023}. Grammar fuzzing requires pre-existing
knowledge of the program being tested, where as Fuzztruction does not. This
makes Fuzztruction more useful in situations where only blackbox and greybox
testing can be carried out, such as for cybersecurity applications
\citep{Fuzztruction_2023}. Several processes, such as identifying instructions
that read/write to/from memory, are carried out on the generator program to
ensure only impactful mutations are applied to the program.
\citet{Fuzztruction_2023} also proposed using Fuzztruction in combination with
a traditional coverage guided fuzzer, such as AFL++. In this configuration,
Fuzztruction and AFL++ are both used to generate input data, with a scheduling
component that enables AFL++ to mutate inputs found by Fuzztruction.
Fuzztruction was compared against existing state of the art general purpose
fuzzers and was shown to outperform all of them in terms of coverage over time.
While the result is very promising, the fuzzer is currently not integrated with
any rehosting based tools, like Unicorn, and so is unable to be used to fuzz
test embedded software.

\citet{Seidel_2023} investigated techniques for creating faster firmware
fuzzers by running emulated arm instructions on native ARM64 hardware. They
implemented SafireFuzz, which used high level emulation techniques from
HALucinator \citep{HALucinator_2020}, and relied on the fact that the ARM
Thumb-v2 instruction set implemented in embedded microcontrollers (ARM
Cortex-M) is available as an execution state in application level processors
(ARM Cortex-A). They implemented a dynamic binary rewriting engine to translate
basic blocks in firmware into compatible native ARM64 instructions. This
near-native execution greatly outperformed existing Unicorn based rehosting
fuzzers, like HALucinator \citep{HALucinator_2020} and Fuzzware
\citep{Fuzzware_2022}, in terms of coverage over time.

\section{Fuzz Testing in the Space Industry}

\citet{Gutierrez_2021} conducted blackbox fuzz testing against the Suchai
CubeSat flight software \citep{Suchai_FSW}. The Suchai flight sofware (FSW) was
designed to be able to run on CubeSat OBCs, such as the GomSpace Nanomind;
microcontrollers, such as ESP32; and both embedded and desktop computers running
Linux. Due to the flexibility in the target hardware, \citet{Gutierrez_2021}
were able to run both the flight software and the fuzzer natively on a general
purpose Linux computer, without any emulation software like Unicorn or QEMU.
The Suchai FSW used a Cubesat Space Protocol (CSP) communication interface for
receiving commands. \citet{Gutierrez_2021} implemented a blackbox fuzzer that
sends random data to the CSP command handler using four different strategies
which constrain input data with different levels of correctness in order to target
different layers of the FSW. For example, the first strategy is to generate
random commands, most of which should be safely rejected by the command
handler; while the third strategy is to generate syntactically valid sets of
commands and parameters, but with randomised parameter values. Their
implementation doesn't seem to have a strategy that randomised the structure of
a CSP packet, so it is assumed that the CSP implementation isn't fuzz tested in
their work.
% However, as the Suchai FSW uses libCSP as an external library to implement the protocol, which may have influenced their decision to not fuzz test the protocol stack.
\citet{Gutierrez_2021} showed that using their blackbox fuzz testing
techniques against the Suchai FSW as part of an agile development process
enabled them to find and resolve bugs in the software that had not been
identified with other testing techniques, and so prove the utility of fuzz
testing flight software.

\citet{Scharnowski_2023} presented a case study where they used Fuzzware
\citep{Fuzzware_2022} to fuzz test three CubeSat FSW images that run on ARM
Cortex-M STM32F4 microcontrollers. This showed Fuzzware to be effective at
identifying bugs in flight software, and demonstrated different methods of
configuring Fuzzware to improve fuzzing effectiveness. The specific focus of
these configurations in a flight software context was to enable the fuzzer to
correctly move through the complex boot process present in the satellite
firmware, to be able to fuzz the application. These configurations included
manually specifying MMIO accesses and % to move through the boot section,
taking snapshots of the firmware state after booting to allow future runs to
fuzz test from that state; or extending Fuzzware to implement AFL++ features
not previously implemented in UnicornAFL \citep{Scharnowski_2023}. In addition
to the complexity of satellite FSW boot processes, another challenge identified
was that the MMIO based approach used by Fuzzware does not automatically analyse
interrupt timing requirements, which can make it difficult for the fuzzer to
reach code that have dependencies on hardware features like DMA (direct memory
access). Ultimately, they conclude that while their methodology was effective,
the current need for a human expert to configure the fuzzer to be effective
makes the use of Fuzzware less feasible as part of continuous integration of
satellite firmware \citep{Scharnowski_2023}.

\citet{Willbold_2024} conducted an investigation into the application of
current state of the art fuzz testing methodologies in the context of security
analysis of satellite flight software. They identify the attack surfaces of
satellites, such as telecommands from the ground, or components integrated in
the satellite suffering from supply chain attacks. They also outline challenges
with fuzz testing specific to satellites, including the complexity of satellite
computer boot processes (as discussed by \citet{Scharnowski_2023}), and the
difficulty of fuzz testing on target hardware. They identify that most fuzzers use crashes as
the measure of failure, and state that for satellite software a crash/reboot
may not be the most problematic outcome. Examples of more severe outcomes
include triggering end of life procedures such as de-orbiting and battery
passivation, modifying orbit parameters, and disabling radios. They also
comment on the general complexity of software systems in satellites, with most
being highly integrated bespoke distributed systems with unique combinations of
peripherals and payloads. This makes it difficult to build reusable emulators.
Other industries with similar levels of complexity, such as automotive and
aviation, often have larger resources for a single project, which makes
building and maintaining emulators more cost effective.

\citet{Willbold_2024} conducted three case studies using different fuzzing
methodologies against different flight software targets.

The first case study used a technique called subsystem extraction, against a
target software known as "Flying Laptop". The Flying Laptop FSW was an RTEMS
system running on a LEON3 processor, which uses the SPARC instruction set. The
telecommand (TC) processing subsystem in the flight software was manually
identified and extracted into a Linux executable, that could be run inside an
emulated SPARC Linux environment. Creating a Linux executable enabled the use
of general purpose fuzzing tools like AFL++, rather than firmware specific
fuzzing tools. This approach was limited to fuzzing the TC processing
subsystem, which in some use cases may be beneficial as it avoided difficulties
with the complex boot sequence, and removed dependencies on hardware. However,
those parts of the FSW would not verified. Furthermore, porting the FSW
components to be able to run on Linux, which made use of RTEMS primitives and
had many other low level incompatible dependencies, was lot of work. As a
result, this case study was not completed \citep{Willbold_2024}.

The second case study use the flight software from ESA's OPS-SAT CubeSat \citep{opsat}, and
used a technique \citet{Willbold_2024} called full system emulation with
persistent mode fuzzing. The OPS-SAT FSW ran on an AVR32 microcontroller, and
\citet{Willbold_2024} had to create an AVR32 instruction set emulator in QEMU:
The AVR32 instruction set is not supported by Unicorn \citep{Unicorn}. This,
again, was a large amount of work. Though \citet{Willbold_2024} justified the
investment as only needing to be done once, and they published their
emulator implementation for others to use. In this case study, hardware
peripherals like sensors and actuators were modelled to provide constant
values. The goal of this case study was to complete a minimal working emulator
that would enable the firmware to receive and process TCs during fuzz testing.
Therefore, as with the first case study, this method was only able to produce
useful results for the TC handling software components. Fuzzing produced
basic block coverage of 76\% of this component, and successfully identified a
buffer overflow bug in the software \citep{Willbold_2024}. In order to improve
execution time, the emulator would only intermittently reboot the firmware
between fuzzer inputs. While this improved the speed of the fuzzing by reducing
the overhead of executing the boot process every iteration, this resulted in
some crashes that were not reproducible due to accumulated state
\citep{Willbold_2024}.

The final case study used flight software from the ESTCube-1 CubeSat, and used
an approach \citet{Willbold_2024} called full firmware rehosting. They used
Hoedur \citep{Hoedur_2023} to rehost and fuzz test the FSW, and found only
a small amount of manual work was required for the fuzzing to work correctly in
comparison to the previous case studies. Hoedur was shown to reach 78\% basic
block coverage in the TC handler functions in the ESTCube-1 FSW, and identified
several crashing inputs. The only feature of Hoedur that \citet{Willbold_2024}
identified as lacking was an inability to detect non-crashing faults. However,
they outlined that by marking an area of memory as "read only" in the Hoedur
configuration file, the software would trigger a crash if it wrote to that
location. Using Hoedur was shown to require much less effort than the other
approaches, as well as effectively manage the challenge of fuzzing complex boot
processes in satellite software. \citet{Willbold_2024} conclude that rehosting
tools like Hoedur represent the most promising approach to fuzz testing for
satellite software security analysis.



% 19 papers, any more, we have other references for information:
% - Cratere_2024
% - Farges_2022
% - Godefroid_2012 (whitebox fuzzing for security testing)
% - Krishnamoorthy_2010 (symbolic execution test generation...)
% - Svoboda_2021 (how exploitable is c code)
% - Abdumohasan_2021 (analytical review of cybersecurity for embedded systems)
% - \citet{Hernandez_2022} FirmWire (dynamic analysis of cellular baseband firmware) less relevent maybe?


% We got Willbold using Hoedur
% We got Scharnowski talking about interrupts and DMA being an issues for Fuzzware/Hoedur
% Hoedur, protocol fuzzing, etc.
%


\end{document}
