\documentclass[../report.tex]{subfiles}
\graphicspath{{\subfix{../images}}}
\begin{document}

%% Software Design?

% [ ] Outline software design needed to meet requirements
% - list all software developed, why they are needed, what requirement they satisfy
% - explain design decisions, such as STM32, DBC, minimal rtos, unicorn
% [ ] Outline tasks needed to meet requirements

% Software tools required:
%  * ground software:
%   ** send and receive spacepackets
%   ** blackbox fuzzer
%    *** grammar filter
%    *** raw data
%  * rehosting software (emulator)
%   ** interrupt handling

All the software implemented is included in a single repository, using a
makefile to build, program, and run the FSW on the target hardware and the
emulator. Files for the flight software implementation are included in the
\lstinline|fsw| directory. Files for the emulator implementation are included
in the \lstinline|emu| directory, and files for the protocol grammar filter
are included in the \lstinline|pgf| directory. The ground software python tool
is located at the project root called \lstinline|gsw|. The \lstinline|pgf| is
not a standalone application, like the \lstinline|emu| and \lstinline|gsw|
tools, but a library containing code that allows the protocol grammar filter to
be used in both the emulator and the ground software.

% Implementation (and Testing?)
% FIXME does implementation section include discussion of implementation decisions? Yes probably.
\section{Flight Software}

Key features of the FSW implementation are outlined and discussed in the
following sections.

\subsection{C Programming Language} %TODO is this necssary as a sub section?

The most logical and popular choice of programming language for embedded flight
software is the C programming language. C is used in FSW frameworks like Gen1
and cFS \citep{Bal_FSDK, Nasa_cFS}. Languages like C++ and Ada are also
commonly used, C++ is used in the F Prime FSW framework \citep{Nasa_fprime}.
Recently, modern languages like Micropython, Rust and Zig have started to
become popular for embedded devices. Rust was used by the University of
Stuttgart for their sat-rs flight software library, which flew as an experiment
on the ESA OPS-SAT satellite \citep{satrs, opsat}. However, support for these
modern languages is still in progress, and currently do not have the stability
required for commercial projects. In preparing for developing the flight
software, an initial bare metal program for the STM32 BlackPill was built using
Zig, but it was decided that using Zig over C would add unneccesarry complexity
and reduce the representativeness of the FSW.

\subsection{Design By Contract}

The FSW made use of design by contract (DBC) as a methodology for ensuring the
correctness of the implementation. The \lstinline|dbc_assert.h| header file
from \citet{dbc_assert} was integrated into the FSW. This header file provided
macros for DBC primitives like pre and post conditions and assertions, which
were used throughout the software to check for common C errors, such as passing
null pointers to functions and size parameters exceeding static limits. When a
DBC assertion check fails (i.e. a pointer is null), the macro calls a
\lstinline|DBC_fault_handler| function, which must be implemented. The
implementation of this handler can be tailored according to the application. In
the FSW implementation, the handler prints a DBC failure message and enters an
infinite loop. However, a release version of the FSW might disable the
execution of the fault handler entirely, or have the fault handler
automatically trigger a reset of the system. It was reasoned that DBC would be
a complementary approach to fuzz testing, as the execution of the
\lstinline|DBC_fault_handler| function would imply a bug in the software, and
should be easy to detect both on target and rehosted, by monitoring the debug
log and program counter respectively.

\subsection{Real Time Operating System}

Requirement \refreq{FSW-9} specified the need for an RTOS in the FSW, to make
the implementation representative. An alternative to using an RTOS is the
"superloop" architecture, where all execution happens in a single while loop.
This architecture is also commonly used in flight software, but mostly for
Telemetry Nodes, which only need to execute a small number of functions. An OBC
software typically needs to be able to execute multible threads concurrently,
which cannot be done using a superloop architecture. There are alternative
concurrent architectures, such as the active object based QP framework
\citep{QP}. However, RTOS is the most commonly used design.

Common RTOS implementations used in flight software include FreeRTOS, RTEMS and
VxWorks \citep{Cratere_2024}. FreeRTOS is open source, and so the use of this
was investigated for the project. However, rather than use an existing RTOS
implementation, it was ultimately decided to develop a simple multitasking RTOS
for the STM32 Blackpill, based on the educational RTOS MiROS \citep{miros}.
While this was less representative, the decision increased the simplicity of
the FSW, and developing the RTOS using educational resources would make the
implementation of emulator features required to support the RTOS much easier.

This RTOS ... % TODO outline rtos

\subsection{Hardware Abstraction Layer}

ARM Cortex-M devices have two distinct layers of hardware implementation. The
core hardware architecture, what makes a chip an ARM Cortex-M, is provided by
ARM, and includes the basic designs needed for the device to function. This
layer includes the processor and hardware peripherals like the nested vector
interrupt controller (NVIC), which manages and dispatches interrupts, or the
serial wire debug (SWD) interface, which provides developers with a universal
interface for programming and debugging firmware on ARM Cortex-M
microcontrollers \citep{armcm4_manual}. ARM provide a software library for
interacting with this layer of the hardware, called the Common Microcontroller
Software Interface Standard (CMSIS) \citep{CMSIS}. CMSIS provides a level of portability to
embedded software by seperating the interface for interacting with hardware
from the implementation, similar to a vendor HAL.

An ARM Cortex-M chip will include another layer of hardware implemenation,
designed by the vendor (STMicroelectronics for the STM32F411xC). This
layer includes additional hardware peripherals, such as memory, IO devices like
USART or I2C, clocks, GPIOs and so on. Vendors typically provide a HAL, which
is a software implementations for interfacing with the vendor hardware. ST
Microelectronics provide a HAL implementation for STM32 devices
\citep{stm32hal}. These HALs can vary in size and complexity from vendor to
vendor, and many are either built on top of CMSIS or compatible with CMSIS.
Often these HAL implementations are part of a developer tooling ecosystem, and
are intergrated into a proprietary IDE. While this can make getting started
with development easier, it can result in vendor lock in, where skills and
knowledge gained using one vendor are difficult to transfer to another vendor.
Additionally, it can be difficult to introspect the binary produced through
these IDEs, and therefore not easy to determine exactly what code and functions
have been included. With the same reasoning as the RTOS implementation, it was
determined that only elements of the hardware abstraction layer required for
the FSW should be included. Therefore, a minimal HAL
(\lstinline|fsw/{inc,src}/hal|) was developed by consulting the STM32F411xC/E
Reference Manual and Datasheet \citep{stm32f4_manual, stm32f4_datasheet}, and
the ARM Cortex-M4 User Manual \citep{armcm4_manual}. This decision also led to
the manual implementation of several parts of the FSW project that are often
provided by the vendor. Namely the startup code
(\lstinline|fsw/src/hal/startup.c|), a linkerscript for the blackpill
(\lstinline|fsw/stm32f411xx.ld|), and a \lstinline|make| build system for
compiling the project with the \lstinline|arm-none-eabi-gcc| toolchain
(\lstinline|Makefile|).

% TODO outline hal files and functionality for peripherals, and why they were needed
% - RCC
% - SysTick
% - uart.h
% - startup.c vector table, default interrupt handlers and fault handlers
% - linker script takes sections of the code from the compiled object files and
%   puts them into the memory locations specified. in this file we define the
%   stack end and other symbols used in the startup code.

It was initially decided to exclude CMSIS from the project in addition to the
vendor HAL. However, later in development the USART HAL implementation added
non blocking (i.e. interrupt driven) reading of USART data, at which point
further interfacing with the NVIC peripheral was required. It was determined
that re-implementing the NVIC API in CMSIS woud make the project more complex
than including the CMSIS library. Therefore a subset of files necessary for
using an ARM Cortex-M4 were included from CMSIS-core \citep{CMSIS} in
\lstinline|fsw/CMSIS|, and were configured for the stm32f411xe
(\lstinline|fsw/inc/hal/stm32f4_blackpill.h|).

% FIXME is this discussion?
In retrospect, while implementing a reduced HAL did make it simpler to emulator
in parallel to the flight software, CMSIS should have been included from the
start of the project, as this would have avoided a lot of difficulty when
developing the lower level parts of the FSW.

\subsection{Application}

The application code

\subsection{Tooling}

% - Written in C? The only real choice
% - Bare Metal
%   - HAL
%   - Startup Code
%   - Design by Contract
% - Actions, Parameters, Telemetries, RPC
% - Spacepacket Interface
% - Bare Metal RTOS inspired by MIROS (rather than FreeRTOS or RTEMS, easier to reason about and emulate for the demonstration of the project)
% - CMSIS? Avoid using relying on CMSIS to reduce the amount of perhipherals and mmio that would need to be emulated.

% Implemented in the C language

% Discuss tooling, rationale for development decisions?

% Talk through all the tools that you had to develop, explain problems that
% were encountered, and their resolutions, explain bugs found and methodologies
% they were resolved.

% overview of tooling developed? identify dependencies, modified design choices, not implementing space data link layer.

% brief overview of iterative development process, with features implemented between tooling alongside each other

% section about flight software
% linker scripts, makefiles, writing the hal
% utils

\section{Emulator}

% section about emulator development
% - unicorn only an ISA emulator
% - discuss implementation of interrupt handling, trampoline handlers


% TODO this can go in results/testing/discussion section?
% section about testing on hardware, and bugs discovered, addition of framing and


\section{Fuzzer Integration and Protocol Grammer Filter}

% modification to emulator to get it to work as a afl++ test harness?
% using docker to run AFL

% FIXME Discussion?
As the PGF can only introduce known errors into the protocol, the design of the
PGF is a compromise between comprehensive fuzzing and specific manually
designed system testing.

% design the input format
% outline the output
% outline the set of known errors based on spacepacket fields

\section{FIXME REMOVE}
% DEMO TEXT BELOW
This is the chapter in which you review the implementation and testing decisions and issues, and critique these processes.

Code can be output inline using \verb@\lstinline|some code|@.  For example, this code is inline: \lstinline|public static int example = 0;| (we have used the character \verb@|@ as a delimiter, but any non-reserved character not in the code text can be used.)

Code snippets can be output using the \verb|\begin{lstlisting} ... \end{lstlisting}|
environment with the code given in the environment. For example, consider listing \ref{Example-Code}, below.

\begin{lstlisting}[breaklines,breakatwhitespace,caption={Example code},label=Example-Code]
public static void main() {

  System.out.println("Hello World");

}
\end{lstlisting}

Code listings are produced using the package `listings'.  This has many useful options, so have a look at the package documentation for further ideas.

\end{document}
