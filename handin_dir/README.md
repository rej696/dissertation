# STM32 Flight Software Development, Emulation, and Fuzzing
This project consists of:
- A bare metal "Flight Software" application for the STM32F411CE "Blackpill" microcontroller board `fsw`:
    - Remote Procedure Call implementation over Serial using Spacepackets and KISS framing
    - Design by Contract
    - Basic RTOS implementation inspired Miro Samek's MIROS
- A python emulator/fuzzing test harness using unicorn `emu`:
    - Arm Cortex-M and STM32 Peripheral models
    - Interrupt handling and context switching
    - A protocol grammar filter for converting a raw byte stream into valid input data (spacepackets with checksums in KISS frames)
    - black box fuzzing (with or without grammar filtering)
- A "Ground Segment" python cli tool `spp`:
    - reading/writing packets to a connected development board
    - on target black box fuzzing (with or without grammar filtering)

## Instructions
### Docker
All dependencies (beyond hardware) are included in the Dockerfile, and hardware
independent functions of the project can be run within the docker image.

You can install docker on your machine following the [instructions online](https://docs.docker.com/engine/install/)

You can build the docker image with `docker build -t rej696/afl:latest .`, or `make docker-build`

You can then run the container and drop into a shell using
`docker run --rm -it --name fuzz -v $(pwd):/src rej696/afl bash` or `make docker-bash`

### STM32 "Flight Software" Application
To compile the STM32 flight software, you can use the docker container, or install:
- make
- arm-none-eabi-gcc toolchain

Compile with `make build`

#### Hardware
You need:
- The [STM32 blackpill development board](https://thepihut.com/products/stm32f411-blackpill-development-board)
    - [blackpill information](https://stm32-base.org/boards/STM32F411CEU6-WeAct-Black-Pill-V2.0.html)
- Two [FTDI cables](https://thepihut.com/products/ftdi-serial-ttl-232-usb-cable) connected to USART1 and USART2 with some jumper wires (see blackpill pinout)
- An [st-link v2](https://thepihut.com/products/st-link-stm8-stm32-v2-programmer-emulator) connected to serial wire debug

To interact with hardware, I recommend you install the arm-none-eabi toolchain locally.
You also need to install the [st-link tools](https://github.com/stlink-org/stlink).

With the st-link connected to the board, you can flash the device with `make flash`

With USART2 connected to your PC with the FTDI cable, you can monitor the debug
output from the STM32 with `./spp --dev /dev/ttyUSB1 log`. Make sure the --dev
argument matches the port your FTDI cable is using.

With USART1 connected to your PC with the FTDI cable, you can send/receive
packets to/from the STM32 with the `spp` python tool.

You can use the tool to trigger specific functions, for example `./spp --dev
/dev/ttyUSB0 action 0` sends a packet to the device to run action with id 0.

You can also use the "blackbox fuzzer" functionality of the tool with `./spp
--dev /dev/ttyUSB0 fuzz --timeout 5`. This will periodically send packets
created from a random bytestream through the protocol grammar filter.

run `./spp --help` for more information.

### Emulator
For interacting with the emulator, I recommend running any commands in the
docker container by first running `make docker-bash` to launch the container
and drop into the shell.

You can run the compiled flight software using the python emulator, by writing
either `make emu` or `make emu-raw`.

These commands will configure the unicorn emulator with the fight software
binary, and a set of hardcoded inputs which will be written to the `USART1`
model at intervals determined by the input data.

`make emu` uses the protocol grammar filter to deterministically generate the
spacepacket data from the input data

`make emu-raw` uses hardcoded raw spacepacket data that have been written by
hand.

When the Emulator runs out of input data, the emulation ends after a timeout
period.

#### Rehosted Black Box Fuzzing
A blackbox fuzzer is also implemented for the Emulator. Running the command
`make emu-bb` will launch the Emulator with a stream of random bytes as the
input data, which is lazily consumed by the protocol grammar filter to generate
spacepackets and trigger sending them to the emulated flight software.

Similarly, running `make emu-bb-raw` will use the random bytestream generated
by the blackbox fuzzer as raw input to the emulated flight software. As this is
a blackbox fuzzer, it is improbable that the random bytestream will result in
any valid packets being sent to the flight software.

#### Rehosted Coverage Guided Fuzzing
The unicorn emulator also acts as a test harness for AFLplusplus unicorn mode,
which allows for rehosted coverage guided fuzzing of the flight software.

AFLplusplus requires a directory containing known valid inputs to begin
fuzzing. These inputs can be generated by running `make gen-fuzz-inputs`, which
runs a python script to generate valid raw data, and valid inputs to the
grammar filter. These initial data are the same as those input when running
`make emu{,-raw}`.

After generating the input data, the grammar fuzzer can be run with `make
fuzz`, and the raw data fuzzer can be run with `make fuzz-raw`
AFLplusplus disables debug output by default, so `make fuzz-debug` and `make
fuzz-raw-debug` run the fuzzer with debug enabled, to help identify any issues
that occur with running the fuzzer.

To achieve good results, the fuzzer should be left as long as possible. As the
fuzzer will be running in a docker container, you can detach from the container
with `C-p C-q` to leave it to run in the background. `make docker-logs` will
follow the stdout of the detached container, and `make docker-attach` will
reattach to the running container.

To stop fuzzing, reattach to the container and type `C-c`. The
`{grammar,raw}_fuzz_outputs` directories will contain the results from running
the fuzzer. There are various tools available in the container for analysing
these.
- `afl-plot grammar_fuzz_outputs/default grammar_fuzz_plot`
    - will generate plots of the fuzzer activity, showing coverage (edges) over
      time
- `afl-showmap -C -i grammar_fuzz_outputs -o /dev/null -- python -m emu/build/firmware.bin -g -i @@`
    - will calculate the total "coverage", though this is in edges and not a
      valid percentage coverage of the flight software

I have also included a python script which will run each input files generated
by the afl fuzzer in order and calculate the flight software statement coverage
and running total. This is run with `make cov{,-raw}`. The output from this
tool can be collated and plotted to show coverage against time/number of execs
for the fuzzing run.

See the
[AFLplusplus documentation](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md)
for more information about running AFLplusplus


## Links
- [Unicorn Engine Notes](https://github.com/alexander-hanel/unicorn-engine-notes)
- [Unicorn AFL Python Example](https://github.com/AFLplusplus/AFLplusplus/tree/stable/unicorn_mode/samples/python_simple)
